Idea:
(I have some similar ideas written up elsewhere ... should reference them too.)

Summary, or at least inspiration: slitherlink on a sphere.

Not just a topologically spherical surface, although that's part of it;
I also want to display it as a sphere in 3D. (The back side would be faintly visible
or not at all.)

Because of the positive curvature of the sphere's surface, you can't use a regular tessellation (at least not that I know of).
You will instead have a geodesic grid where most faces might be hexagons but a few will
be pentagons, for example.
- This is actually two distinct possibilities: geodesic grid,
  where all faces are triangles, most vertices have degree 6,
  but some have degree 5;
- and the dual, Goldberg polyhedra, where most faces are hexagons,
  12 are pentagons, (or you can have squares or triangles) and all
  vertices have degree 3.

See https://www.youtube.com/watch?v=0TGNg8CGWoE#t=15 regarding Conway's Life on a
geodesic grid.

Useful and practical how-to: http://blog.chronoclast.com/2010/01/so-i-wanted-to-tinker-with-hex-grid.html

http://stemkoski.github.io/Three.js/Sphere-Project.html
has good code for drawing the arc between two points on a sphere.
This is optional; we can draw straight lines. But it would be a nice plus.

three.js has functions to build a geodesic grid based on subdivision of an icosahedron,
which is the grid I'll likely use.
However I think I will probably need to roll my own code for the geodesic grid...
or copy-and-modify theirs... because I don't think I can use the same data structures that
three.js does... Its "faces" are all triangles.

Wait, maybe I can use http://stemkoski.github.io/Three.js/Topology-Data.html
or http://stemkoski.github.io/Three.js/Topology-Data-2.html
"From a THREE.Geometry, creates a topological data structure consisting of vertices, edges, and faces, with incidence data for each. For this example, the corresponding geometry is labeled (including edges) and the data can be manually verified from the browser console." Part 2 "illustrates edge and face subdivision and retriangulation functions and proper face coloring function".

That might work, but beware that it preserves the "face = triangle" (or possible "face = square") oddity of computer graphics. So this data structure might be fine for display,
but there would have to be translation to/from the underlying polyhedron model where a face can be a pentagon etc.

However, I could adapt Stemkowski's code to make a general polyhedron model...
or better, `I could look for another library with a polyhedron or geometry data structure
that has an interface to Three.js.
But I don't seem to find one.
Maybe just roll my own DCEL (https://en.wikipedia.org/wiki/Doubly_connected_edge_list).
"DCEL is more than just a doubly linked list of edges. In the general case, a DCEL contains a record for each edge, vertex and face of the subdivision. Each record may contain additional information, for example, a face may contain the name of the area. Each edge usually bounds two faces and it is therefore convenient to regard each edge as two half-edges."
https://github.com/hapticdata/toxiclibsjs looks promising, but its geometry seems to be limited to triangular faces.
JTS and JSTS and some other libraries that are described as "geometry" libraries 
are 2D-only, but it's hard to dig out that limitation.


Hm, what about the data structure used by http://stemkoski.github.io/Three.js/Polyhedra.html ? Its faces are not restricted to triangles.
However, it doesn't have a way to get from face to face, edge to face, etc. directly.
But it has an interesting polyhedronDataToMesh() function that I could adapt, to
get data from polyhedral representation to triangulated Three.js mesh.

But as far as geometry is concerned,
http://stemkoski.github.io/Three.js/Polyhedra.html
is a great example of the fact that we don't need to be restricted to geodesic grids
that try to maximize isotropy and equal area. Instead, we can use polyhedra like archimedean solids (and project the vertices to the sphere if desired)! So... We can do things like snub icosidodecahedron, and go further
iterations to make things even more complicated (more faces).
See http://stemkoski.github.io/Three.js/Polyhedra.html
for base code for generating and displaying polyhedra.

See http://www.georgehart.com/sculpture/roads-untaken.html for a neat idea
for a suitable polyhedron, with 902 cells (faces); at the bottom of the page is a link
to the wrl model, but it's expressed as "the compound of six pentagonal prisms", so
it's not a single surface yet in this form. Maybe the easiest way to convert it would
be to use software like a mesh viewer (MeshLab), combine the six prisms, and take the convex hull? Geolib (http://www.geolib.co.uk/features.htm) provides union and convex
hull operations, but isn't free (for continued use).


The https://en.wikipedia.org/wiki/Elongated_square_gyrobicupola
should be a fun one, though it's a very small grid.
So would the soccer ball (truncated icosahedron)

Some cool polyhedra to use or build on are the ones found at https://en.wikipedia.org/wiki/Conway_polyhedron_notation#Icosahedral_symmetry
e.g. saD, stI, tkt5daD, tktI, dk6k5tI, tk5sD, C200jC200jC200jC200jO (credit to Anna), optionally with more iterations

I would probably like to avoid polyhedra where there is a big disparity between
face sizes. In general. Well, I think the real issue is that we don't want any one face
getting too small (relative to the whole polyhedron), because it would be hard to display a clue in it; or any one edge
too short, because it would be hard to click on or display an X on. So yes it helps to have face sizes (and edge sizes) fairly uniform, but that depends somewhat on how
many faces and edges there are. If there are fewer, then it's OK to have some that are
bigger/smaller, and still be able to have all of them big enough.

To do [done]: it might help to add another couple of stats to polyhedronisme: 
show minimum edge and face size (as a fraction of the unit size, whatever is
used in the resize poly function). The size of a face could be defined as the
minimum distance from its center to one of its edges' centers.

Could also do something like standard deviation of face radii. But is that worth it?

Maybe I can take several of the polyhedra from http://stemkoski.github.io/Three.js/Polyhedra.html
and/or
http://www.netlib.org/polyhedra/index.html
and use edge-truncation, vertex-truncation, cantellation, omnitruncation, etc. on them to add detail.
Another method would be subdividing each face, and projecting the
resulting vertices to the sphere. Be careful that the resulting faces are indeed planar.

Note that truncation can be applied to any polyhedron, but uniform truncation may
only apply to *regular* polyhedra. Same with cantellation.
Note also that truncation doubles the number of sides of each face (and adds more faces).
So if we just keep doing truncation, we end up with very-many-sided faces.
We could alternate truncation and subdivision-with-projection.

Things to guard against, with semi-automated checking:
- very-many-sided faces. A few of these are OK.
- too-skinny polygons (defined by radius of inscribed circle?).
   Could try to fix this by
  - merging adjacent polygons? but since they're not coplanar, we'd have to
    resubdivide them somehow...
  - subdividing the long skinny ones; but they'd still be very small
- very small polygons (relative to the average area?)
  
Another source of geodesic grids would be fullgen https://cs.anu.edu.au/people/Brendan.McKay/plantri/
It "generates fullerenes, which are planar cubic graphs having only faces of size 5 or 6"
The version of it described at https://caagt.ugent.be/CaGe/Archive/fullgen.html
will output a 3D representation, which we need.

Note that the generation of polyhedron meshes would probably be done server-side,
because the generation of slitherlink puzzles would likely be done server-side.
Right? 
Well, theoretically the generation of puzzles could soon be client-side.


This is getting to be a big clump of to-do's. Let's break it down...

A- would like something for me to experiment with operations on convex polyhedra,
  but iterative, so that I can try the effect of truncating, truncating again,
  subdividing faces, and so on. Features:
  - undo
  - probly in javascript (Three.js), for easy and sharable interactive graphics 
    - but we'd need a separate representation of geometry from Three.js's triangulated geom
  - export result to a useful geometric format (and optionally, to a triang-mesh format)
    so we can use it in B and C.
  This tool could start from http://stemkoski.github.io/Three.js/Polyhedra.html
  but check his license. See https://github.com/stemkoski/stemkoski.github.com/issues/30    
  
  OK, A is really done, thanks to http://levskaya.github.io/polyhedronisme/
  There are some improvements I'd like to make, but I can make them myself (and submit
  pull requests) and deploy my own version, so I'm good.
  There's no "undo", but since it's all just coded "recipes", undo is easy to do by hand.
  I could wish for a script-driven way to generate many polygons and tune them
  in a (semi)automated way, but that could be further down the road.
  

B- need to be able to generate solvable slitherlink puzzles, given a graph.
  Can use Krazydad's code for that, depending on the usage and his agreement.
  If so, need conversion from the format we have to his format (modified to add z coord).
  Krazydad's code doesn't care about coordinates, so we don't have to "unwrap" to 2D.
  
  So, the next step is to look back at his code, what format it requires; what modif-
  ications did I already make to it to take 3D coordinates and such; maybe this step
  is already done?
    
  OK, I believe this is done. I modified slitherlinkNGon to SlitherlinkNGon3D,
  so it preserves 3D coordinates. The display works. I modified the output
  to be OBJ plus comments encoding the numeric clues and also the solution.
  
  Actually, I might want to instead have it output JSON (similar to Stemkowski's
  Three.js example)  so that it can be quickly loaded by the web app.
  (Done)
  
C- need to be able to display a slitherlink puzzle in Three.js
  Requires loading from OBJ or similar data, with clues and solution,
  to some slitherlink data structure. The latter probably needs something full-featured
  similar to a DCEL, because nice UI features require awareness of relationships btwn
  faces, edges, vertices, and their neighbors.
  
[Obsolete:
Progress so far:
- I have made some progress on A. Adapting Stemkowski's Topology and Polyhedra demos,
  I've gotten it to
    1- load from the minimal polyhedron data format in polyhedra.js and store
       in "rich polyhedron" data structure, which at the moment is just Stemkowski's topology;
    2- convert from rich polyhedron to mesh for display (richPolyhedronToMesh()).
    It works! It comes up displaying a cube.
    So the next step is
    3- add controls and functions to truncate the polyhedron in memory, and display
    the result.
]
    
On truncation algorithm, see section 3.1 of http://www.mi.sanu.ac.rs/vismath/akleman/
"We use Chaikin's algorithm to determine the positions of the new vertices after a cut operation, i.e., we cut each line from 1/4 and 3/4. ... Comparing to polyhedral vertex truncation, this new vertex truncation scheme has several advantages. It is stationary and simple to implement. Moreover, the scheme is robust, i.e. it can be applied to any manifold mesh."
Good description of Chaikin's algorithm, and of a spline/subdivision alternative, which
would result in more rounded instead of flattened polyhedra:
http://www3.cs.stonybrook.edu/~qin/courses/geometry/subdivision.pdf


Hm, try TopMod: https://www.viz.tamu.edu/faculty/ergun/research/topology/download.html
for Windows (older version available for Mac).


Oh wow, I just stumbled across
http://levskaya.github.io/polyhedronisme/
which lets you apply multiple operations to a base polygon.
The selection of bases is small, but you can build whatever you want by the
operations, right?


You can also do this using the web page at
http://www.georgehart.com/virtual-polyhedra/conway_notation.html
which will output VRML (.WRL) but doesn't display the result.
Maybe its output is better quality, though.
However I can’t find a working VRML viewer!


Idea for UI:  might be fun to have some holes in the polygons. For visual drama.
- without affecting real topology: just use holes in the UI as a way of indicating "zero"
  clues: a hole means that the path cannot touch of it. Drawback: we lose symmetry.
- without affecting real topology: just use holes in the UI for random faces
  that don't have clues. The path can touch them. Keep holes sparse and never let
  two holes touch.
- connected with real topology: we make holes in the polygon way back in the pipeline,
  when we generate the original object data. Then the puzzle-generating code will
  need to understand about holes, and will need to avoid letting the solution touch
  them (or it can touch them, but no clues are allowed on the holes?)
- The presence of holes would mean that we have to draw the backs of back faces,
  as well as the fronts of front faces.
  
  
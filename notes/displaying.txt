Displaying faces, edges, text, and vertices

FACES

Requirements:

Faces need to have a number (clue) displayed on them.
The clues may also need to have color, e.g. to highlight zeroes, or
an error condition (a face has more edges filled in than the clue number).

We may want them to have different colors; e.g. to show
which faces are "inside" the loop and which are "outside."

We may also want faces to be opaque, so that the back side (or even number) of other faces
facing away from the viewer don't have to be displayed. (Although the user might want to be
able to see clues from the opposite side, as an option... but I don't want to support that in v1.)

Implementation:

One option for displaying faces with colors and numbers (text) on them is
to use Geometry's .faceVertexUvs property
(https://threejs.org/docs/index.html#api/core/Geometry.faceVertexUvs),
allows you to specify texture coordinates for each vertex on each face.

This will let us specify a color for each face, by referencing a texture with desired
colors on it. (We could load a pre-baked texture from the server, or possibly
create the texture dynamically. It could be very small, maybe 2x2 pixels per color.)

If we use texture Uvs for numbers as well, we'd need to have a larger texture that
has each digit prerendered on each of the possible face colors. So that would be at
least 11 digits (the eleventh is no digit) * 3 colors (inside/outside/unknown); possibly 
*2 if we have digits in red to indicate an error.

So much prebaking seems like it would be a pain to update.

Another option for showing digits (text) would be to use text shape geometry:
https://threejs.org/examples/?q=text#webgl_geometry_text_shapes
We could still use texture UVs for the face colors, but then have the
flexibility to do the digits separately in regard to position and color.

We'd have to compute their position, using some math ... including the
face normal vector, centroid, radius, and optimal (or good enough) orientation.
(We'd need most of those anyway, even if we used texture UVs.)

What about TextGeometry? How is that different from Text Shape Geometry?
I believe it's for true 3D text. (We don't need that.)

**Different approach, maybe simpler:
Stemkoski's polyhedron viewer (http://stemkoski.github.io/Three.js/Polyhedra.html)
puts all polygon faces (meaning cells) into a single geometry, but then sets the
color of each triangulated subface to the desired color! Pretty clever.


EDGES

Requirements:

Edges will need 3 states: on, off, and unknown (initial state).
That could be done with colors, e.g. using the .colors property of the geometry
of the LineSegments, which allows you to specify a color per vertex,

The same should work for MeshLine, but remember to check MeshLineMaterial.map and .useMap.

Alternatively, MeshLine seems to support dashes, so that would be one way
to indicate a state.

See also https://threejs.org/examples/?q=inter#webgl_interactive_lines
which shows lines in different colors and dashed.

http://stemkoski.github.io/Three.js/Polyhedra.html uses cylinders to display
edges. All the cylinders are amalgamated into a single geometry.
How would that hold up with the number of edges I'm contemplating?
Can I feed his program a large polyhedron and see?
Would have to download and reproduce his code, and augment his polyhedra.js data file.


VERTICES

At this point I'm not sure that vertices need to be displayed at all. It may be
nice for aesthetic purposes.
If so, we could use billboard circles (something called Dots?); glowing stars...

http://stemkoski.github.io/Three.js/Polyhedra.html uses spheres, merged together
into a single geometry. That could work...

He also puts all the faces, edges, and vertices into a single Object3D.


PICKING

This demo https://github.com/mrdoob/three.js/blob/master/examples/webgl_interactive_buffergeometry.html
does picking this way: It uses a raycaster from the mouse position and camera, and then
   var intersects = raycaster.intersectObject( mesh );
to get the faces of the mesh object that are intersected by the ray from the mouse.
For this we would need to be able to map from mesh triangulated "faces" to polyhedron cells.
and from sub "faces" to edges. And vertices.

Could we do this by adding an attribute to each sub "face"? I think so.

We could keep cells, edges, and vertices as 3 separate objects, and run raycast.intersectObject()
on one at a time. Start with edges, and if there's no result there, run it on faces.
